# 어셈블리 기본 구성 및 핵심 정리

## 1. 어셈블리 기본 구성

1.  메모리 내용을 레지스터로 가져와 CPU에서 실행
2.  레지스터, 주기억장치는 CPU가 주의해야 할 장소
3.  명령어 형식: `[label :] mnemonic [operands][ ; comment]`
4.  Operand 종류:
    -   **Immediate:** 즉시값
    -   **Register:** 레지스터
    -   **Memory:** 메모리

------------------------------------------------------------------------

## 2. Operand Notation

-   범용 레지스터: AX\~DX (16비트)
-   AX 구성: 왼쪽 AH (High), 오른쪽 AL (Low)

  AH           AL
  ------------ ------------
  상위 8비트   하위 8비트

-   세그먼트 레지스터: CS, DS, SS, ES, FS, GS
-   reg/mem 8\~32비트 형식 외우기

------------------------------------------------------------------------

## 3. Direct Memory Operands

``` asm
.data
var1 BYTE 10h
mov al, var1 ; var1 값을 al로 이동
```

-   `.data` 내 정의된 변수의 주소는 **데이터 세그먼트**가 관리한다.

------------------------------------------------------------------------

## 4. MOV Instruction

-   형식: `mov destination, source`
-   특징:
    1.  동일한 비트 크기여야 함
    2.  메모리-메모리 간 이동 불가
    3.  destination 변경됨
    4.  IP는 destination 불가
    5.  명령어 크기만큼 IP 증가

------------------------------------------------------------------------

## 5. 데이터 크기

  타입    크기 (Byte)   비트
  ------- ------------- ------
  BYTE    1             8
  WORD    2             16
  DWORD   4             32

------------------------------------------------------------------------

## 6. MOVZX / MOVSX

-   **MOVZX:** Zero Extension (상위 0 채움)
-   **MOVSX:** Sign Extension (상위부 부호비트 채움)

``` asm
movzx ax, byteVal ; 00000000 10001111b
movsx ax, byteVal ; 11111111 10001111b (상위비트가 1이면)
```

------------------------------------------------------------------------

## 7. LAHF / SAHF

-   **LAHF:** FLAG → AH로 로드
-   **SAHF:** AH → FLAG로 저장
-   FLAG는 연산 결과 상태를 나타내며, JUMP 명령 등에 사용됨

------------------------------------------------------------------------

## 8. XCHG (교환)

``` asm
mov ax, val1
xchg ax, val2
mov val1, ax
```

-   메모리-메모리 교환 불가 (레지스터 필수)

------------------------------------------------------------------------

## 9. Direct Offset Operands

``` asm
mov al, arrayB
mov al, [arrayB+1]
```

-   배열은 0부터 시작
-   `[arrayB+1]` 은 다음 메모리 주소 참조

------------------------------------------------------------------------

## 10. INC / DEC

``` asm
inc myWord
dec myWord
```

------------------------------------------------------------------------

## 11. ADD / NEG

-   **ADD:** `add destination, source`
-   **NEG:** 2의 보수로 부호 반전

------------------------------------------------------------------------

## 12. Flag Register (EFLAGS)

  플래그   의미        설명
  -------- ----------- -----------------------------------------
  CF       Carry       무부호 연산에서 자리 올림/내림
  ZF       Zero        결과가 0이면 1
  PF       Parity      1의 개수 짝수면 1
  SF       Sign        최상위 비트 1이면 음수
  OF       Overflow    부호 있는 연산에서 오버플로우 발생 시 1
  AF       Auxiliary   BCD 연산 시 비트3 캐리

-   하드웨어는 **CF와 MSB**를 XOR하여 오버플로우 감지

------------------------------------------------------------------------

## 13. Data Related Operators / Directives

  연산자     의미                    예시
  ---------- ----------------------- --------------------------
  OFFSET     변수 주소 반환          `mov esi, OFFSET myByte`
  ALIGN      정렬 (짝수 주소 선호)   `align 2`
  PTR        데이터 크기 지정        `BYTE PTR [esi]`
  TYPE       데이터 크기 반환        BYTE=1, WORD=2
  LENGTHOF   배열 개수               
  SIZEOF     배열 전체 바이트 수     

------------------------------------------------------------------------

## 14. Indirect Addressing

``` asm
mov esi, OFFSET byteval
mov al, [esi]
inc BYTE PTR [esi]
```

------------------------------------------------------------------------

## 15. LOOP

``` asm
mov ecx, 5
L1:
  inc ax
  loop L1
```

-   `ECX` 자동 감소 → 0이 되면 루프 종료

------------------------------------------------------------------------

## 16. 배열 덧셈 예시

``` asm
mov esi, OFFSET myArray
mov ecx, LENGTHOF myArray
mov eax, 0
L1:
  add eax, [esi]
  add esi, TYPE myArray
  loop L1
```

